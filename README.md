# No projeto que montamos, usamos uma única MainActivity com um menu inicial que contém botões para acessar diferentes tipos de layout: FrameLayout, LinearLayout, RelativeLayout, ConstraintLayout e RecyclerView. A lógica central é que, quando o usuário clica em um desses botões, a MainActivity troca o layout da tela usando setContentView(). Essa troca de layout é temporária, mas cada layout contém um botão de "Voltar" que permite retornar à tela inicial com o menu, mantendo a navegação simples e intuitiva dentro de um único Activity.

# O FrameLayout é um layout que empilha elementos sobrepostos. No nosso exemplo, ele continha uma imagem de fundo (ImageView), um texto (TextView) posicionado centralizado sobre a imagem e um botão de voltar na parte inferior da tela. Esse layout é ideal quando você quer colocar algo em cima de outra coisa, como textos sobre imagens, botões sobre vídeos ou animações, ou telas de carregamento com componentes flutuantes. No código, o botão "Voltar" é colocado com layout_gravity="bottom|center" para sempre aparecer na parte inferior da tela, independentemente da imagem ou do texto, mostrando como o FrameLayout lida bem com sobreposição, mas não organiza elementos lado a lado ou em sequência.

# O LinearLayout organiza os elementos em linha ou coluna. No exemplo, usamos orientação vertical para dispor alguns textos e depois um botão de voltar. Cada elemento aparece um abaixo do outro, seguindo a sequência do XML. Esse layout é muito útil para formulários, listas curtas de botões ou textos que precisam aparecer sequencialmente. A principal vantagem é a simplicidade: os elementos aparecem exatamente na ordem em que foram declarados, mas a limitação é que, para layouts mais complexos, pode ser necessário aninhar vários LinearLayouts, o que deixa a hierarquia pesada. No código, quando o usuário clica no botão "LinearLayout" no menu, o MainActivity troca o layout para layout_linear e o botão "Voltar" permite retornar ao menu principal.

# O RelativeLayout permite posicionar elementos em relação uns aos outros ou às bordas da tela. No nosso exemplo, o primeiro texto estava alinhado ao topo da tela, o segundo texto aparecia logo abaixo do primeiro e o botão de voltar ficava fixo na parte inferior. Isso demonstra o funcionamento do RelativeLayout: é possível criar relações de posicionamento entre elementos sem depender da sequência em que foram declarados. Ele é útil quando você quer, por exemplo, que um botão sempre fique abaixo de um texto, que uma imagem fique alinhada à direita de outro componente ou que um elemento esteja centralizado horizontalmente em relação a outro. É mais flexível que LinearLayout, mas menos moderno que ConstraintLayout.

# O ConstraintLayout é o mais poderoso e flexível dos layouts que usamos. No código, ele tinha um texto centralizado exatamente no meio da tela e um botão de voltar fixado no canto inferior direito. O ConstraintLayout permite criar relacionamentos de alinhamento entre qualquer elemento e qualquer borda da tela ou outro elemento, sem precisar aninhar múltiplos layouts. É ideal para interfaces modernas que precisam se adaptar a diferentes tamanhos de tela e resoluções. No exemplo, o texto centralizado mostra como é fácil posicionar elementos no centro usando constraints, enquanto o botão de voltar demonstra que podemos posicionar elementos em pontos específicos da tela sem criar hierarquias complexas.

# Por fim, usamos o RecyclerView, que é um componente especializado para exibir listas grandes e otimizadas. No exemplo, criamos uma lista de 15 itens (Item 1, Item 2, etc.) e o botão de voltar abaixo da lista. O RecyclerView funciona com um LayoutManager (neste caso, LinearLayoutManager para exibir itens em coluna) e um Adapter que popula os itens da lista. A vantagem do RecyclerView é que ele reaproveita as células da lista, tornando a renderização muito mais eficiente do que criar dezenas ou centenas de elementos individualmente. No código, assim que o usuário clica no botão "RecyclerView", o MainActivity troca o layout para layout_recycler, inicializa o RecyclerView, define seu layout e preenche os itens usando o MyAdapter, e o botão de voltar permite retornar ao menu inicial.

# Em resumo, o projeto mostra na prática como cada layout funciona: o FrameLayout é ideal para sobreposição, o LinearLayout para sequências simples, o RelativeLayout para posicionamentos relativos, o ConstraintLayout para interfaces flexíveis e modernas, e o RecyclerView para listas grandes e performáticas. A MainActivity gerencia toda a navegação, usando setContentView() para trocar o layout ativo e botões de "Voltar" para manter o controle da navegação sem precisar criar várias Activities. Dessa forma, é possível testar todos os layouts em um único aplicativo, observar seu comportamento e entender para quais cenários cada um é mais útil.
